"use strict";(self.webpackChunkchargepi=self.webpackChunkchargepi||[]).push([[319],{5460:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(758);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},6015:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"go-client/adding-support-for-hardware","title":"\u27a1\ufe0fAdding hardware support","description":"There are four hardware component groups that are included in the project:","source":"@site/docs/go-client/adding-support-for-hardware.md","sourceDirName":"go-client","slug":"/go-client/adding-support-for-hardware","permalink":"/docs/go-client/adding-support-for-hardware","draft":false,"unlisted":false,"editUrl":"https://github.com/ChargePi/ChargePi-docs/edit/master/docs/go-client/adding-support-for-hardware.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"\ud83c\udfc3 Running the client","permalink":"/docs/go-client/running-the-client"},"next":{"title":"OCPP 1.6","permalink":"/docs/ocpp/ocpp-16"}}');var a=t(6070),i=t(5460);const o={sidebar_position:4},s="\u27a1\ufe0fAdding hardware support",d={},l=[{value:"\ud83d\udcb3 Reader hardware",id:"-reader-hardware",level:2},{value:"\ud83d\udda5\ufe0f Display hardware",id:"\ufe0f-display-hardware",level:2},{value:"Indicator hardware",id:"indicator-hardware",level:2},{value:"\u26a1 EVCC",id:"-evcc",level:2},{value:"\u26a1 Power meters",id:"-power-meters",level:2},{value:"\u26a1 EVCC",id:"-evcc-1",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"\ufe0fadding-hardware-support",children:"\u27a1\ufe0fAdding hardware support"})}),"\n",(0,a.jsx)(n.p,{children:"There are four hardware component groups that are included in the project:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"NFC/RFID tag reader,"}),"\n",(0,a.jsx)(n.li,{children:"LCD (display),"}),"\n",(0,a.jsx)(n.li,{children:"(Led) Indicator,"}),"\n",(0,a.jsx)(n.li,{children:"Power meter,"}),"\n",(0,a.jsx)(n.li,{children:"EVCC."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["These hardware components have corresponding interfaces that are included in the ",(0,a.jsx)(n.code,{children:"ChargePointHandler"})," struct. This\nallows adding support for other models of hardware with similar functionalities."]}),"\n",(0,a.jsxs)(n.p,{children:["You're welcome to submit a Pull Request with any additional hardware model implementations! Be sure to test and document\nyour changes, update the ",(0,a.jsx)(n.a,{href:"../hardware/hardware.md",children:"supported hardware"})," table(s) with the new hardware model(s). It would\nbe nice to have a wiring sketch or a connection table included for the new model(s)."]}),"\n",(0,a.jsx)(n.h2,{id:"-reader-hardware",children:"\ud83d\udcb3 Reader hardware"}),"\n",(0,a.jsxs)(n.p,{children:["All readers must implement the ",(0,a.jsx)(n.code,{children:"Reader"})," interface. It is recommended that you implement the interface in a new file\nnamed after the model of the reader in the ",(0,a.jsx)(n.code,{children:"hardware/reader"})," package. Then you should add a ",(0,a.jsx)(n.strong,{children:"constant"})," named after\nthe ",(0,a.jsx)(n.strong,{children:"model"})," of the reader in the ",(0,a.jsx)(n.code,{children:"reader"})," file in the package and add a switch case with the implementation and the\nnecessary logic that returns a pointer to the struct."]}),"\n",(0,a.jsxs)(n.p,{children:["The settings of the reader are read from the ",(0,a.jsx)(n.code,{children:"settings.json"})," file, which is stored in the cache and are available in the\nNewTagReader method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package reader\n\nimport (\n\t"context"\n\t"errors"\n\tlog "github.com/sirupsen/logrus"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n)\n\n// Supported readers - by libnfc\nconst (\n\tPN532 = "PN532"\n)\n\nvar (\n\tErrReaderUnsupported = errors.New("reader type unsupported")\n\tErrReaderDisabled    = errors.New("reader disabled")\n)\n\n// Reader is an abstraction for an RFID/NFC tag reader.\ntype Reader interface {\n\tListenForTags(ctx context.Context)\n\tCleanup()\n\tReset()\n\tGetTagChannel() <-chan string\n}\n\n// NewTagReader creates an instance of the Reader interface based on the provided configuration.\nfunc NewTagReader(reader settings.TagReader) (Reader, error) {\n\tif reader.IsEnabled {\n\t\tlog.Infof("Preparing tag reader from config: %s", reader.ReaderModel)\n\n\t\tswitch reader.ReaderModel {\n\t\tcase PN532:\n\t\t\treturn nil, nil\n\t\t\t// Your custom implmentation\n\t\tdefault:\n\t\t\treturn nil, ErrReaderUnsupported\n\t\t}\n\t}\n\n\treturn nil, ErrReaderDisabled\n}\n\n'})}),"\n",(0,a.jsx)(n.h2,{id:"\ufe0f-display-hardware",children:"\ud83d\udda5\ufe0f Display hardware"}),"\n",(0,a.jsxs)(n.p,{children:["All displays must implement the ",(0,a.jsx)(n.code,{children:"LCD"})," interface. It is recommended that you implement the interface in a new file named\nafter the model of the display/LCD in the ",(0,a.jsx)(n.code,{children:"hardware/display"})," package. Then you should add a ",(0,a.jsx)(n.strong,{children:"constant"})," named after\nthe ",(0,a.jsx)(n.strong,{children:"model"})," of the display in the ",(0,a.jsx)(n.code,{children:"display"})," file in the package and add a switch case with the implementation and the\nnecessary logic that returns a pointer to the struct."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package display\n\nimport (\n\t"context"\n\t"errors"\n\tlog "github.com/sirupsen/logrus"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n\t"time"\n)\n\nconst (\n\tDriverHD44780 = "hd44780"\n)\n\nvar (\n\tErrDisplayUnsupported = errors.New("display type unsupported")\n\tErrDisplayDisabled    = errors.New("display disabled")\n)\n\ntype (\n\t// LCDMessage Object representing the message that will be displayed on the LCD.\n\t// Each array element in Messages represents a line being displayed on the 16x2 screen.\n\tLCDMessage struct {\n\t\tMessages        []string\n\t\tMessageDuration time.Duration\n\t}\n\n\t// LCD is an abstraction layer for concrete implementation of a display.\n\tLCD interface {\n\t\tDisplayMessage(message LCDMessage)\n\t\tListenForMessages(ctx context.Context)\n\t\tCleanup()\n\t\tClear()\n\t\tGetLcdChannel() chan<- LCDMessage\n\t}\n)\n\n// NewMessage creates a new message for the LCD.\nfunc NewMessage(duration time.Duration, messages []string) LCDMessage {\n\treturn LCDMessage{\n\t\tMessages:        messages,\n\t\tMessageDuration: duration,\n\t}\n}\n\n// NewDisplay returns a concrete implementation of an LCD based on the drivers that are supported.\n// The LCD is built with the settings from the settings file.\nfunc NewDisplay(lcdSettings settings.Display) (LCD, error) {\n\tif lcdSettings.IsEnabled {\n\t\tlog.Info("Preparing LCD from config")\n\n\t\tswitch lcdSettings.Driver {\n\t\tcase DriverHD44780:\n\t\t// custom implementation\n\t\tdefault:\n\t\t\treturn nil, ErrDisplayUnsupported\n\t\t}\n\t}\n\n\treturn nil, ErrDisplayDisabled\n}\n\n'})}),"\n",(0,a.jsx)(n.h2,{id:"indicator-hardware",children:"Indicator hardware"}),"\n",(0,a.jsx)(n.p,{children:"The process is the same as the previous description."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package indicator\n\nimport (\n\t"errors"\n\tlog "github.com/sirupsen/logrus"\n\t"github.com/spf13/viper"\n)\n\n// color constants\nconst (\n\tOff    = 0x0\n\tWhite  = 0xFFFFFF\n\tRed    = 0xff0000\n\tGreen  = 0x00ff00\n\tBlue   = 0x000ff\n\tYellow = 0xeeff00\n\tOrange = 0xff7b00\n)\n\n// Supported types\nconst (\n\tTypeWS281x = "WS281x"\n)\n\nvar (\n\tErrInvalidIndex        = errors.New("invalid index")\n\tErrInvalidPin          = errors.New("invalid data pin #")\n\tErrInvalidNumberOfLeds = errors.New("number of leds must be greater than zero")\n)\n\ntype (\n\t// Indicator is an abstraction layer for connector status indication, usually an RGB LED strip.\n\tIndicator interface {\n\t\tDisplayColor(index int, colorHex uint32) error\n\t\tBlink(index int, times int, colorHex uint32) error\n\t\tCleanup()\n\t}\n)\n\n// NewIndicator constructs the Indicator based on the type provided by the settings file.\nfunc NewIndicator(stripLength int) Indicator {\n\tvar (\n\t\tindicatorEnabled = viper.GetBool("chargepoint.hardware.ledIndicator.enabled")\n\t\tindicatorType    = viper.GetString("chargepoint.hardware.ledIndicator.type")\n\t\tindicateCardRead = viper.GetBool("chargepoint.hardware.ledIndicator.indicateCardRead")\n\t)\n\n\tif indicatorEnabled {\n\t\tif indicateCardRead {\n\t\t\tstripLength++\n\t\t}\n\n\t\tlog.Infof("Preparing Indicator from config: %s", indicatorType)\n\t\tswitch indicatorType {\n\t\tcase TypeWS281x:\n\t\t\t// Your custom implementation\n\t\tdefault:\n\t\t\treturn nil, ErrReaderUnsupported\n\t\t}\n\t}\n\n\treturn nil\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"-evcc",children:"\u26a1 EVCC"}),"\n",(0,a.jsx)(n.p,{children:"The process is similar to other components. Note: Init method will be called whenever the charge point boots.\nThe init method should perform any necessary setup steps, such as opening a communication path. Any two-way\ncommunication should be initiated in another thread and should communicate through channels."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package evcc\n\nimport (\n\t"context"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n)\n\nconst (\n\tPhoenixEMCPPPETH = "EM-CP-PP-ETH"\n\tRelay            = "Relay"\n)\n\ntype (\n\tEVCC interface {\n\t\tInit(ctx context.Context) error\n\t\tEnableCharging() error\n\t\tDisableCharging()\n\t\tSetMaxChargingCurrent(value float64) error\n\t\tGetMaxChargingCurrent() float64\n\t\tLock()\n\t\tUnlock()\n\t\tGetState() string\n\t\tCleanup() error\n\t}\n)\n\n// NewPowerMeter creates a new power meter based on the connector settings.\nfunc NewEVCCFromType(evccSettings settings.EVCC) (EVCC, error) {\n\tswitch evccSettings.Type {\n\tcase Relay:\n\t\treturn nil, nil\n\tcase PhoenixEMCPPPETH:\n\t\treturn nil, nil\n\t\t// Your custom implementation\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"-power-meters",children:"\u26a1 Power meters"}),"\n",(0,a.jsx)(n.p,{children:"The process is the same as the previous description."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package powerMeter\n\nimport (\n\t"context"\n\t"errors"\n\tlog "github.com/sirupsen/logrus"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n)\n\n// Supported power meters\nconst (\n\tTypeC5460A = "cs5460a"\n)\n\nvar (\n\tErrPowerMeterUnsupported = errors.New("power meter type not supported")\n\tErrPowerMeterDisabled    = errors.New("power meter not enabled")\n)\n\n// PowerMeter is an abstraction for measurement hardware.\ntype (\n\tPowerMeter interface {\n\t\tInit(ctx context.Context) error\n\t\tReset()\n\t\tGetEnergy() float64\n\t\tGetPower() float64\n\t\tGetCurrent() float64\n\t\tGetVoltage() float64\n\t\tGetRMSCurrent() float64\n\t\tGetRMSVoltage() float64\n\t}\n)\n\n// NewPowerMeter creates a new power meter based on the connector settings.\nfunc NewPowerMeter(meterSettings settings.PowerMeter) (PowerMeter, error) {\n\tif meterSettings.Enabled {\n\t\tlog.Infof("Creating a new power meter: %s", meterSettings.Type)\n\n\t\tswitch meterSettings.Type {\n\t\tcase TypeC5460A:\n\t\t\t// Your custom implementation\n\t\t\treturn nil, nil\n\t\tdefault:\n\t\t\treturn nil, ErrPowerMeterUnsupported\n\t\t}\n\t}\n\n\treturn nil, ErrPowerMeterDisabled\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"-evcc-1",children:"\u26a1 EVCC"}),"\n",(0,a.jsx)(n.p,{children:"The process is similar to other components. Note: Init method will be called whenever the charge point boots.\nThe init method should perform any necessary setup steps, such as opening a communication path. Any two-way\ncommunication should be initiated in another thread and should communicate through channels."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-golang",children:'package evcc\n\nimport (\n\t"context"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n)\n\nimport (\n\t"context"\n\t"errors"\n\tlog "github.com/sirupsen/logrus"\n\t"github.com/xBlaz3kx/ChargePi-go/internal/models/settings"\n)\n\n// Supported power meters\nconst (\n\tPhoenixEMCPPPETH = "EM-CP-PP-ETH"\n\tRelay            = "Relay"\n)\n\ntype (\n\tEVCC interface {\n\t\tInit(ctx context.Context) error\n\t\tEnableCharging() error\n\t\tDisableCharging()\n\t\tSetMaxChargingCurrent(value float64) error\n\t\tGetMaxChargingCurrent() float64\n\t\tLock()\n\t\tUnlock()\n\t\tGetState() string\n\t\tCleanup() error\n\t}\n)\n\n// NewPowerMeter creates a new power meter based on the connector settings.\nfunc NewEVCCFromType(evccSettings settings.EVCC) (EVCC, error) {\n\tswitch evccSettings.Type {\n\tcase Relay:\n\t\treturn nil, nil\n\tcase PhoenixEMCPPPETH:\n\t\treturn nil, nil\n\t\t// Your custom implementation\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);